const entitySymbol=Symbol(),subEntitiesSymbol=Symbol(),basePathSymbol=Symbol();class SirenError extends Error{constructor(t){super(t)}}function areEqual(t,e){return Array.isArray(t)?Array.isArray(e)&&t.length===e.length&&t.every((t=>e.includes(t))):t===e}class EntityWrapper{constructor(t,e){this[entitySymbol]=t,this[basePathSymbol]=e,this._toAbsolutePaths()}_toAbsolutePaths(){if(this[basePathSymbol]){"string"==typeof this[entitySymbol].href&&(this[entitySymbol].href=new URL(this[entitySymbol].href,this[basePathSymbol]).href);for(const t of this.links())"string"==typeof t.href&&(t.href=new URL(t.href,this[basePathSymbol]).href)}}hasClass(t){return!!this[entitySymbol].class&&this[entitySymbol].class.includes(t)}get class(){return this[entitySymbol].class||[]}get title(){return this[entitySymbol].title||""}get properties(){return this[entitySymbol].properties||{}}get href(){return this[entitySymbol].href}get rel(){return this[entitySymbol].rel}links(t){const e=this[entitySymbol].links||[];return t?("string"==typeof t&&(t=[t]),Array.isArray(t)?e.filter((e=>areEqual(t,e.rel))):e.filter((e=>{for(const i in t)if(!areEqual(e[i],t[i]))return!1;return!0}))):e}hasLink(t){return siren.isLink(this.link(t))}link(t){if("string"==typeof t&&(t=[t]),Array.isArray(t)){for(const e of this.links())if(areEqual(t,e.rel))return e}else for(const e of this.links()){let i=!0;for(const r in t)if(!areEqual(t[r],e[r])){i=!1;break}if(i)return e}return emptyLink}hasEntity(t){if(this[entitySymbol].entities){"string"==typeof t&&(t=[t]);for(const e of this[entitySymbol].entities)if(areEqual(e.rel,t))return!0;return!1}return this.entity(t)!==emptyEntity}entities(t){return this[entitySymbol].entities&&(this[subEntitiesSymbol]=this[entitySymbol].entities.map((t=>siren.entity(t,this[basePathSymbol]))),delete this[entitySymbol].entities),t?("string"==typeof t&&(t=[t]),this.entities().filter((e=>areEqual(e.rel,t)))):this[subEntitiesSymbol]||[]}entity(t){"string"==typeof t&&(t=[t]);for(const e of this.entities())if(areEqual(e.rel,t))return e;return emptyEntity}}const emptyEntity=Object.freeze(new EntityWrapper({})),emptyLink=Object.freeze({}),siren={isEntity:function(t){return t instanceof EntityWrapper},entity:function(t,e){return t?siren.isEntity(t)?t:new EntityWrapper(t,e):emptyEntity},isLink:function(t){return!!(t&&t.href&&t.rel)},isSubEntity:function(t){return!(!siren.isEntity(t)||!t.rel)},isSubEntityEmbeddedLink:function(t){return!(!siren.isEntity(t)||!siren.isLink(t))},request:function(t){let e;if(siren.isLink(t)?e=t:siren.isEntity(t)&&(e=t.link("self")),!siren.isLink(e))throw new SirenError("No link information found to create request for this entity");const i=new Headers;return e.type?i.set("Accept",e.type):i.set("Accept","application/vnd.siren+json,application/json;q=0.9,*/*;q=0.8"),new Request(e.href,{method:"GET",headers:i})}};export default siren;